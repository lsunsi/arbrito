{
  "language": "Solidity",
  "sources": {
    "contracts/Arbrito.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.5;\n\nimport \"./external/IBalancer.sol\";\nimport \"./external/IUniswap.sol\";\nimport \"./external/IERC20.sol\";\nimport \"./external/IWeth.sol\";\n\ncontract Arbrito is IUniswapPairCallee {\n  enum Borrow { Token0, Token1 }\n\n  address[] public tokens;\n  mapping(address => uint256) public balances;\n\n  address immutable WETH_ADDRESS;\n  address immutable UNISWAP_ROUTER_ADDRESS;\n  address payable immutable OWNER;\n\n  constructor(address wethAddress, address uniswapRouterAddress) {\n    UNISWAP_ROUTER_ADDRESS = uniswapRouterAddress;\n    WETH_ADDRESS = wethAddress;\n    OWNER = msg.sender;\n  }\n\n  receive() external payable {}\n\n  function perform(\n    Borrow borrow,\n    uint256 amount,\n    address uniswapPair,\n    address balancerPool,\n    address uniswapToken0,\n    address uniswapToken1,\n    uint256 uniswapReserve0,\n    uint256 uniswapReserve1,\n    uint256 balancerBalance0,\n    uint256 balancerBalance1\n  ) external {\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapPair(uniswapPair).getReserves();\n\n    require(\n      borrow == Borrow.Token0\n        ? (reserve0 >= uniswapReserve0 && reserve1 <= uniswapReserve1)\n        : (reserve0 <= uniswapReserve0 && reserve1 >= uniswapReserve1),\n      \"Uniswap reserves mismatch\"\n    );\n\n    {\n      uint256 balance0 = IBalancerPool(balancerPool).getBalance(uniswapToken0);\n      uint256 balance1 = IBalancerPool(balancerPool).getBalance(uniswapToken1);\n\n      require(\n        borrow == Borrow.Token0\n          ? balance0 <= balancerBalance0 && balance1 >= balancerBalance1\n          : balance0 >= balancerBalance0 && balance1 <= balancerBalance1,\n        \"Balancer balances mismatch\"\n      );\n    }\n\n    bytes memory payload =\n      abi.encode(balancerPool, uniswapToken0, uniswapToken1, reserve0, reserve1);\n\n    if (borrow == Borrow.Token0) {\n      IUniswapPair(uniswapPair).swap(amount, 0, address(this), payload);\n    } else {\n      IUniswapPair(uniswapPair).swap(0, amount, address(this), payload);\n    }\n  }\n\n  function uniswapV2Call(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external override {\n    (\n      address balancerPoolAddress,\n      address token0,\n      address token1,\n      uint256 reserve0,\n      uint256 reserve1\n    ) = abi.decode(data, (address, address, address, uint256, uint256));\n\n    uint256 amountTrade;\n    uint256 amountPayback;\n\n    address tokenPayback;\n    address tokenTrade;\n\n    if (amount0 != 0) {\n      amountTrade = amount0;\n      (tokenTrade, tokenPayback) = (token0, token1);\n      amountPayback = calculateUniswapPayback(amountTrade, reserve1, reserve0);\n    } else {\n      amountTrade = amount1;\n      (tokenPayback, tokenTrade) = (token0, token1);\n      amountPayback = calculateUniswapPayback(amountTrade, reserve0, reserve1);\n    }\n\n    allow(sender, balancerPoolAddress, tokenTrade, amountTrade);\n\n    (uint256 balancerAmountOut, ) =\n      IBalancerPool(balancerPoolAddress).swapExactAmountIn(\n        tokenTrade,\n        amountTrade,\n        tokenPayback,\n        amountPayback,\n        uint256(-1)\n      );\n\n    require(IERC20(tokenPayback).transfer(msg.sender, amountPayback), \"Payback failed\");\n\n    if (balances[tokenPayback] == 0) {\n      tokens.push(tokenPayback);\n    }\n\n    balances[tokenPayback] += balancerAmountOut - amountPayback;\n  }\n\n  function allow(\n    address owner,\n    address spender,\n    address token,\n    uint256 amount\n  ) internal {\n    if (IERC20(token).allowance(owner, spender) < amount) {\n      IERC20(token).approve(spender, uint256(-1));\n    }\n  }\n\n  function calculateUniswapPayback(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256) {\n    uint256 numerator = reserveIn * amountOut * 1000;\n    uint256 denominator = (reserveOut - amountOut) * 997;\n    return numerator / denominator + 1;\n  }\n\n  function withdraw() external {\n    address[] memory path = new address[](2);\n    address me = address(this);\n    path[1] = WETH_ADDRESS;\n\n    uint256 weth = 0;\n    for (uint256 i = 0; i < tokens.length; i++) {\n      address token = tokens[i];\n\n      if (token == WETH_ADDRESS) {\n        weth += balances[token];\n      } else {\n        path[0] = token;\n\n        allow(me, UNISWAP_ROUTER_ADDRESS, token, balances[token]);\n\n        weth += IUniswapRouter(UNISWAP_ROUTER_ADDRESS).swapExactTokensForTokens(\n          balances[token],\n          0,\n          path,\n          me,\n          block.timestamp\n        )[1];\n      }\n\n      delete balances[token];\n    }\n\n    delete tokens;\n\n    IWeth(WETH_ADDRESS).withdraw(weth);\n    OWNER.transfer(weth);\n  }\n}\n"
    },
    "contracts/external/IBalancer.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.5;\n\ninterface IBalancerPool {\n  function swapExactAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    address tokenOut,\n    uint256 minAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n\n  function getBalance(address token) external view returns (uint256);\n}\n"
    },
    "contracts/external/IUniswap.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.5;\n\ninterface IUniswapPairCallee {\n  function uniswapV2Call(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n}\n\ninterface IUniswapRouter {\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n}\n\ninterface IUniswapPair {\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/external/IERC20.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.5;\n\ninterface IERC20 {\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "contracts/external/IWeth.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.5;\n\ninterface IWeth {\n  function withdraw(uint256 wad) external;\n}\n"
    },
    "test/external/Weth.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.5;\n\nimport \"../../contracts/external/IWeth.sol\";\nimport \"./IERC20.sol\";\n\ncontract Weth is ERC20Mintable, IWeth {\n  receive() external payable {\n    balances[msg.sender] += msg.value;\n  }\n\n  function withdraw(uint256 wad) external override {\n    require(balances[msg.sender] >= wad, \"insufficient amount\");\n    balances[msg.sender] -= wad;\n    msg.sender.transfer(wad);\n  }\n}\n"
    },
    "test/external/IERC20.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.5;\n\ninterface IERC20 {\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract ERC20 is IERC20 {\n  mapping(address => uint256) balances;\n  mapping(address => mapping(address => uint256)) allowances;\n\n  function balanceOf(address account) external view override returns (uint256) {\n    return balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount) external override returns (bool) {\n    if (balances[msg.sender] < amount) {\n      return false;\n    }\n\n    balances[msg.sender] -= amount;\n    balances[recipient] += amount;\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external override returns (bool) {\n    require(allowances[sender][msg.sender] >= amount, \"no allowance\");\n    allowances[sender][msg.sender] -= amount;\n\n    if (balances[sender] < amount) {\n      return false;\n    }\n\n    balances[sender] -= amount;\n    balances[recipient] += amount;\n    return true;\n  }\n\n  function allowance(address owner, address spender) external view override returns (uint256) {\n    return allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    allowances[msg.sender][spender] = amount;\n    return true;\n  }\n}\n\ncontract ERC20Mintable is ERC20 {\n  function mint(address account, uint256 amount) external {\n    balances[account] += amount;\n  }\n}\n"
    },
    "test/external/Uniswap.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.5;\n\nimport \"./IERC20.sol\";\nimport \"../../contracts/external/IUniswap.sol\";\n\ncontract UniswapPair is IUniswapPair {\n  address token0address;\n  address token1address;\n  uint112 reserve0;\n  uint112 reserve1;\n\n  constructor(address _token0, address _token1) {\n    token0address = _token0;\n    token1address = _token1;\n  }\n\n  function getReserves()\n    external\n    view\n    override\n    returns (\n      uint112,\n      uint112,\n      uint32\n    )\n  {\n    return (reserve0, reserve1, 0);\n  }\n\n  function refreshReserves() public {\n    address me = address(this);\n    reserve0 = uint112(IERC20(token0address).balanceOf(me));\n    reserve1 = uint112(IERC20(token1address).balanceOf(me));\n  }\n\n  function swap(\n    uint256 amount0,\n    uint256 amount1,\n    address receiver,\n    bytes calldata payload\n  ) external override {\n    require(\n      (amount0 == 0 && amount1 != 0) || (amount0 != 0 && amount1 == 0),\n      \"unsupported amounts\"\n    );\n\n    IERC20 tokenLent;\n    IERC20 tokenPayback;\n    uint256 amountLent;\n    uint256 tokenPaybackBalance;\n\n    if (amount0 != 0) {\n      tokenLent = IERC20(token0address);\n      tokenPayback = IERC20(token1address);\n      amountLent = amount0;\n      tokenPaybackBalance = reserve1;\n      require(IERC20(token0address).transfer(receiver, amount0), \"loan failed\");\n    } else {\n      tokenLent = IERC20(token1address);\n      tokenPayback = IERC20(token0address);\n      amountLent = amount1;\n      tokenPaybackBalance = reserve0;\n      require(IERC20(token1address).transfer(receiver, amount1), \"loan failed\");\n    }\n\n    address me = address(this);\n    uint256 tokenLentBalance = tokenLent.balanceOf(me);\n\n    if (payload.length > 0) {\n      IUniswapPairCallee(msg.sender).uniswapV2Call(msg.sender, amount0, amount1, payload);\n    }\n\n    require(tokenLent.balanceOf(me) == tokenLentBalance, \"unsupported payback\");\n\n    uint256 tokenPaybackBalanceAfter = tokenPayback.balanceOf(me);\n    require(tokenPaybackBalanceAfter > tokenPaybackBalance, \"missing payback\");\n\n    uint256 amountPaidBack = tokenPaybackBalanceAfter - tokenPaybackBalance;\n    uint256 balance0Adjusted = tokenPaybackBalanceAfter * 1000 - amountPaidBack * 3;\n    uint256 balance1Adjusted = tokenLentBalance;\n    require(\n      balance0Adjusted * balance1Adjusted >=\n        (tokenLentBalance + amountLent) * tokenPaybackBalance * 1000,\n      \"payback mismatch\"\n    );\n\n    refreshReserves();\n  }\n}\n\ncontract UniswapRouter is IUniswapRouter {\n  address immutable weth;\n  address immutable token;\n  address immutable pair;\n\n  constructor(\n    address _weth,\n    address _token,\n    address _pair\n  ) {\n    weth = _weth;\n    token = _token;\n    pair = _pair;\n  }\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external override returns (uint256[] memory) {\n    require(amountOutMin == 0, \"amountOutMin must be 0\");\n    require(deadline == block.timestamp, \"deadline must be block.timestamp\");\n    require(path.length == 2, \"path.length must be 2\");\n\n    uint256[] memory amounts = new uint256[](2);\n    amounts[0] = amountIn;\n\n    (uint112 reserve0, uint112 reserve1, ) = UniswapPair(pair).getReserves();\n\n    if (path[0] == weth && path[1] == token) {\n      amounts[1] = getAmountOut(amountIn, reserve0, reserve1);\n\n      IERC20(weth).transferFrom(msg.sender, pair, amountIn);\n      UniswapPair(pair).swap(0, amounts[1], to, new bytes(0));\n    } else if (path[0] == token && path[1] == weth) {\n      amounts[1] = getAmountOut(amountIn, reserve1, reserve0);\n\n      IERC20(token).transferFrom(msg.sender, pair, amountIn);\n      UniswapPair(pair).swap(amounts[1], 0, to, new bytes(0));\n    } else {\n      revert(\"invalid path\");\n    }\n\n    return amounts;\n  }\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint112 reserveIn,\n    uint112 reserveOut\n  ) internal pure returns (uint256) {\n    return (amountIn * reserveOut * 997) / (reserveIn * 1000 + amountIn * 997);\n  }\n}\n"
    },
    "test/external/Balancer.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.5;\n\nimport \"./IERC20.sol\";\nimport \"../../contracts/external/IBalancer.sol\";\n\ncontract BalancerPool is IBalancerPool {\n  uint256 constant BONE = 10**18;\n\n  function swapExactAmountIn(\n    address _tokenIn,\n    uint256 _tokenAmountIn,\n    address _tokenOut,\n    uint256 _minAmountOut,\n    uint256 _maxPrice\n  ) external override returns (uint256, uint256) {\n    require(_maxPrice == uint256(-1), \"Unsupported maxPrice\");\n\n    address me = address(this);\n    IERC20 tokenIn = IERC20(_tokenIn);\n    IERC20 tokenOut = IERC20(_tokenOut);\n\n    uint256 tokenAmountOut =\n      calcAmountOutGivenIn(_tokenAmountIn, tokenIn.balanceOf(me), tokenOut.balanceOf(me), 0);\n    require(tokenAmountOut > _minAmountOut, \"Insufficient amount out\");\n\n    require(tokenIn.transferFrom(msg.sender, me, _tokenAmountIn), \"Transfer in failed\");\n\n    require(tokenOut.transfer(msg.sender, tokenAmountOut), \"Transfer out failed\");\n\n    return (tokenAmountOut, 0);\n  }\n\n  function getBalance(address token) external view override returns (uint256) {\n    return IERC20(token).balanceOf(address(this));\n  }\n\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return (a * b + BONE / 2) / BONE;\n  }\n\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    return (a * BONE + b / 2) / b;\n  }\n\n  function calcAmountOutGivenIn(\n    uint256 a,\n    uint256 bi,\n    uint256 bo,\n    uint256 s\n  ) internal pure returns (uint256) {\n    return bmul(bo, BONE - bdiv(bi, bi + bmul(a, BONE - s)));\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}